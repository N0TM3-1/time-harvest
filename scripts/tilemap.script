local persist = require 'persist.persist' -- Load the Defold Persist library for saving and loading data

local changed_tiles = {} --TIP: Values: x (location); y (location); state (if not crop, tilemap ID); type
local planted_tiles = {} --TIP: Values: x (location); y (location); state

local function save() --IMPORTANT: Possible problems in the future
	persist.create("changed_tiles", changed_tiles, true)
	persist.create("planted_tiles", planted_tiles, true)
end

local function load_map()
	for k, v in pairs(changed_tiles) do
		if v.type == "crop" then
			tilemap.set_tile("#farm", "bg", v.x, v.y, v.state + 3) -- Apply crop state offset (4,5,6)
		else
			tilemap.set_tile("#farm", "bg", v.x, v.y, v.state) -- Non-harvestable tile states remain unchanged
		end
	end
	for k,v in pairs(planted_tiles) do
		tilemap.set_tile("#farm", "bg", v.x, v.y, v.state + 3)
		print("Loaded planted tile at tilemap coordinates  " .. v.x .. ", " .. v.y)
	end
end

local function update_map()
	for k, v in pairs(planted_tiles) do
		tilemap.set_tile("#farm", "bg", v.x, v.y, v.state + 3)
		if v.state < 3 then
			v.state = v.state + 1
		end
	end
	save()
end

function init(self)
	msg.post("/time#time", "req_time") -- Request time from the time script

	-- Check if saved tile data exists
	if not persist.exists("changed_tiles") then
		persist.create("changed_tiles", changed_tiles, false)
	else
		changed_tiles = persist.load("changed_tiles")
	end
	if not persist.exists("planted_tiles") then
		persist.create("planted_tiles", planted_tiles, false)
	else
		planted_tiles = persist.load("planted_tiles")
	end
	load_map()
end

function on_message(self, message_id, message, sender)
	if message_id == hash("planted") then
		table.insert(changed_tiles, {x = message[1], y = message[2], state = 1, type = "crop"})
		table.insert(planted_tiles, {x = message[1], y = message[2], state = 1})
		update_map()
		save()
	elseif message_id == hash("harvest") then
		-- Reset the tile to a harvested state
		tilemap.set_tile("#farm", "bg", message[1], message[2], 2)
	
		for k, v in pairs(planted_tiles) do
			if v.x == message[1] and v.y == message[2] then
				table.remove(planted_tiles, k)
				break
			end
		end
		for k, v in pairs(changed_tiles) do
			if v.x == message[1] and v.y == message[2] and v.type == "crop" then
				table.remove(changed_tiles, k)
				break 
			end
		end	
		save()
	elseif message_id == hash("till") then
		tilemap.set_tile("#farm", "bg", message[1], message[2], 3)
		table.insert(changed_tiles, {x = message[1], y = message[2], state = 3, type = "tilled"}) -- Add tiles to the changed_tiles table
		update_map()
		save()
	elseif message_id == hash("tick") then
		update_map()
	end
end