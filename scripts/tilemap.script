local persist = require 'persist.persist' -- Load the Defold Persist library for saving and loading data

local changed_tiles = {} --TIP: Values: x (location); y (location); state (if not crop, tilemap ID); type

local function update_map()
	for _, tile in pairs(changed_tiles) do
		if tile.type == "crop" then
			tilemap.set_tile("#farm", "bg", tile.x, tile.y, tile.state + 3) -- Apply crop state offset (4,5,6)
		else
			tilemap.set_tile("#farm", "bg", tile.x, tile.y, tile.state) -- Non-harvestable tile states remain unchanged
		end
	end
	persist.create("changed_tiles", changed_tiles, true) --IMPORTANT: Possible problems in the future
end

local function update_state()
	for _, tile in pairs(changed_tiles) do
		if tile.type == "crop" and tile.state < 3 then
			tile.state = tile.state + 1
		end
	end
	update_map()
end

function init(self)
	msg.post("/time#time", "req_time")

	-- Check if saved tile data exists
	if not persist.exists("changed_tiles") then
		persist.create("changed_tiles", changed_tiles, false)
	else
		changed_tiles = persist.load("changed_tiles")
		update_map()
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("planted") then
		table.insert(changed_tiles, {x = message[1], y = message[2], state = 1, type = "crop"})
		update_map()
	end

	if message_id == hash("harvest") then
		-- Reset the tile to a harvested state
		tilemap.set_tile("#farm", "bg", message[1], message[2], 2)
	
		for k, tile in pairs(changed_tiles) do
			if tile.x == message[1] and tile.y == message[2] and tile.type == "crop" then
				tile.type = "grass"
				tile.state = 2 
				break 
			end
		end
	end
	

	if message_id == hash("till") then
		tilemap.set_tile("#farm", "bg", message[1], message[2], 3)
		table.insert(changed_tiles, {x = message[1], y = message[2], state = 3, type = "tilled"})
		update_map()
	end

	if message_id == hash("tick") then
		update_state()
	end

	persist.create("changed_tiles", changed_tiles, true) --IMPORTANT: Possible problems in the future
end